using Godot;
using Godot.Collections;
// using System.Collections.Generic;

public class Bullet : KinematicBody
{
    ImmediateGeometry debugDrawNode;
    ImmediateGeometry debugDrawNode2;
    Vector3 bulletStartPos;
    bool calcDone = false;
    float distance = 1000.0f;
    Dictionary stepPoints;
    int stepCount = 0;
    PhysicsDirectSpaceState spaceState;
    PackedScene ball;
    SpatialMaterial material;
    SpatialMaterial material2;
    Array<PhysicsBody> collisionList;

    // Called when the node enters the scene tree for the first time.
    public override void _Ready()
    {
        if (bulletStartPos == null) {
            bulletStartPos = new Vector3();
        }

        stepPoints = new Dictionary();
        collisionList = new Array<PhysicsBody>();

        debugDrawNode = Main.instance.GetNode("DebugDraw") as ImmediateGeometry;
        material = new SpatialMaterial();
        material.FlagsUnshaded = true;
        material.FlagsUsePointSize = true;
        material.FlagsNoDepthTest = true;
        debugDrawNode.MaterialOverride = material;

        debugDrawNode2 = Main.instance.GetNode("DebugDrawPen") as ImmediateGeometry;
        material2 = new SpatialMaterial();
        material2.FlagsUnshaded = true;
        material2.FlagsUsePointSize = true;
        material2.FlagsNoDepthTest = true;
        material2.AlbedoColor = Colors.Red;
        debugDrawNode2.MaterialOverride = material2;

        ball = ResourceLoader.Load<PackedScene>("res://Scenes/Ball.tscn");
    }

    // Called every frame. 'delta' is the elapsed time since the previous frame.
    public override void _Process(float delta)
    {
        if (!calcDone) {
            GD.Print("Bang!");
            CalcProjectile();
            calcDone = true;
            RestorePrimaryLayer();
            AddToDebugDraw();
        }
    }

    public static Bullet Fire()
    {
        var b = new Bullet();
        b.bulletStartPos = new Vector3(0, 0, 0);
        Main.instance.AddChild(b);
        return b;
    }

    public static Bullet Fire(Vector3 start)
    {
        var b = new Bullet();
        b.bulletStartPos = start;
        Main.instance.AddChild(b);
        return b;
    }

    public void AddToDebugDraw()
    {
        if (Main.debugDraw) {
            for (int i = 0; i < stepCount; i++)
            {
                Vector3 thisStart = (Vector3)((Dictionary)stepPoints[i])["start"];
                Vector3 thisEnd = (Vector3)((Dictionary)stepPoints[i])["end"];
                bool isPen = (bool)((Dictionary)stepPoints[i])["isPen"];

                if (isPen) {
                    debugDrawNode2.Begin(Mesh.PrimitiveType.LineStrip, null);
                    debugDrawNode2.AddVertex(thisStart);
                    debugDrawNode2.AddVertex(thisEnd);
                    debugDrawNode2.End();
                } else {
                    debugDrawNode.Begin(Mesh.PrimitiveType.LineStrip, null);
                    debugDrawNode.AddVertex(thisStart);
                    debugDrawNode.AddVertex(thisEnd);
                    debugDrawNode.End();
                }
            }
        }
    }

    public void CalcProjectile()
    {
        spaceState = Main.instance.GetWorld().DirectSpaceState;
        var camera = Main.camera;
        bulletStartPos = bulletStartPos + camera.ProjectRayNormal(Helpers.GetScreenCenter()) * 4;
        var end = bulletStartPos + camera.ProjectRayNormal(Helpers.GetScreenCenter()) * distance;
        GD.Print("Initial distance: ", bulletStartPos.DistanceTo(end));
        CalcProjectileStepForward(bulletStartPos, end);
    }

    public void CalcProjectileStepForward(Vector3 start, Vector3 origEnd)
    {
        // {
        //     position: Vector3 # point in world space for collision
        //     normal: Vector3 # normal in world space for collision
        //     collider: Object # Object collided or null (if unassociated)
        //     collider_id: ObjectID # Object it collided against
        //     rid: RID # RID it collided against
        //     shape: int # shape index of collider
        //     metadata: Variant() # metadata of collider
        // }
        // var shape = new SphereShape();
        // shape.Radius = 0.025f;
        // // shape. = 0.025f;
        // PhysicsShapeQueryParameters shapeQuery = new PhysicsShapeQueryParameters();
        // shapeQuery.SetShape(shape);
        // var shapeHit = spaceState.IntersectShape(shapeQuery);
        // GD.Print("Heck heck: ", shapeHit);
        var hit = spaceState.IntersectRay(start, origEnd, null, (uint)Wallbang.CollisionMask.LAYER0, true, true);
        var hitEnd = origEnd;

        // Spatial ballStart = (Spatial)ball.Instance();
        // ballStart.GetNode<CSGMesh>("CSGMesh").MaterialOverride = material;
        // var newTrans = ballStart.Transform;
        // newTrans.origin = start;
        // ballStart.Transform = newTrans;
        // Main.instance.AddChild(ballStart);
        if (hit.Contains("position")) {
            hitEnd = (Vector3)hit["position"];
            distance -= start.DistanceTo(hitEnd);
            var body = (PhysicsBody)hit["collider"];
            body.CollisionLayer = (uint)(Wallbang.CollisionMask.LAYER19);
            collisionList.Add(body);
            // spaceState = Main.instance.GetWorld().DirectSpaceState;

            if (distance > 0) {
                CalcProjectileStepBackward(origEnd, hitEnd);
            }
        } else {
            // Spatial ballEnd = (Spatial)ball.Instance();
            // ballEnd.GetNode<CSGMesh>("CSGMesh").MaterialOverride = material;
            // var newTrans2 = ballEnd.Transform;
            // newTrans2.origin = hitEnd;
            // ballEnd.Transform = newTrans2;
            // Main.instance.AddChild(ballEnd);
        }

        var d = new Dictionary();
        d["start"] = start;
        d["end"] = hitEnd;
        d["isPen"] = false;
        AddStep(d);
        // GD.Print("Bullet travel: ", start, hitEnd);
    }

    public void CalcProjectileStepBackward(Vector3 origEnd, Vector3 bulletEntry)
    {
        // {
        //     position: Vector3 # point in world space for collision
        //     normal: Vector3 # normal in world space for collision
        //     collider: Object # Object collided or null (if unassociated)
        //     collider_id: ObjectID # Object it collided against
        //     rid: RID # RID it collided against
        //     shape: int # shape index of collider
        //     metadata: Variant() # metadata of collider
        // }
        var hit = spaceState.IntersectRay(origEnd, bulletEntry, null, (uint)Wallbang.CollisionMask.LAYER19);
        Vector3 bulletExit = bulletEntry;

        // Spatial ballStart = (Spatial)ball.Instance();
        // ballStart.GetNode<CSGMesh>("CSGMesh").MaterialOverride = material2;
        // var newTrans = ballStart.Transform;
        // newTrans.origin = bulletEntry;
        // ballStart.Transform = newTrans;
        // Main.instance.AddChild(ballStart);
        if (hit.Contains("position")) {
            bulletExit = (Vector3)hit["position"];
            distance -= bulletEntry.DistanceTo(bulletExit);
            var body = (PhysicsBody)hit["collider"];

            var d = new Dictionary();
            d["start"] = bulletExit;
            d["end"] = bulletEntry;
            d["isPen"] = true;
            AddStep(d);
            // GD.Print("Bullet penetration: ", bulletExit, bulletEntry);

            CalcProjectileStepForward(bulletExit, origEnd);
        }
    }

    public void AddStep(Dictionary d)
    {
        stepPoints[stepCount] = d;
        stepCount++;
    }

    public void RestorePrimaryLayer()
    {
        foreach (PhysicsBody body in collisionList) {
            body.CollisionLayer = (uint)Wallbang.CollisionMask.LAYER0;
        }
    }
}
